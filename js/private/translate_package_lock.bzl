"Convert package-lock.json into starlark Bazel fetches"

_DOC = """Repository rule to generate npm_import rules from package-lock.json file.

The npm lockfile format includes all the information needed to define npm_import rules,
including the integrity hash, as calculated by the package manager.

Instead of manually declaring the `npm_imports`, this helper generates an external repository
containing a helper starlark module `repositories.bzl`, which supplies a loadable macro
`npm_repositories`. This macro creates an `npm_import` for each package.

Bazel will only fetch the packages which are required for the requested targets to be analyzed.
Thus it is performant to convert a very large package-lock.json file without concern for
users needing to fetch many unnecessary packages.

Typical usage:
```starlark
load("@aspect_rules_js//js:npm_import.bzl", "translate_package_lock")

# Read the package-lock.json file to automate creation of remaining npm_import rules
translate_package_lock(
    name = "npm_deps",
    package_lock = "//:package-lock.json",
)

load("@npm_deps//:repositories.bzl", "npm_repositories")

npm_repositories()
```
"""

_ATTRS = {
    "package_lock": attr.label(
        doc = """The package-lock.json file.
        
        It should use the lockfileVersion 2, which is produced from npm 7 or higher.""",
        mandatory = True,
    ),
}

_NPM_IMPORT_TMPL = """    # @generated from [package-lock.json snippet here]
    npm_import(
        name = "{name}",
        integrity = "{integrity}",
        package = "{package}",
        version = "{version}",
        deps = {deps},
    )
"""

def _escape(package_name):
    "Make a package name into a valid label without slash or at-sign"
    return package_name.replace("/", "_").replace("@", "_")

def _repo_name(package_name, version):
    "Make an external repository name from a package name and a version"
    return "npm_%s-%s" % (_escape(package_name), version)

def _import_dependencies(repository_ctx, bzl_out, packages):
    for (name, dep) in packages["dependencies"].items():
        if "resolved" not in dep.keys():
            continue
        deps = []
        if "requires" in dep.keys():
            for (n, d) in dep["requires"].items():
                deps.append("@" + _repo_name(n, d))
        bzl_out.extend([_NPM_IMPORT_TMPL.format(
            name = _repo_name(name, dep["version"]),
            package = name,
            version = dep["version"],
            url = dep["resolved"],
            integrity = dep["integrity"],
            deps = deps,
        )])

def _translate_package_lock(repository_ctx):
    bzl_content = ["""# @generated by package_lock.bzl from {package_lock}

load("@aspect_rules_js//js:npm_import.bzl", "npm_import")

def npm_repositories():
    "Define external repositories to fetch each tarball individually from npm on-demand."
"""]

    lock_content = json.decode(repository_ctx.read(repository_ctx.attr.package_lock))
    lock_version = lock_content["lockfileVersion"]
    if lock_version < 2:
        fail("translate_package_lock only works with npm 7 lockfiles (lockfileVersion >= 2), found %s" % lock_version)

    _import_dependencies(repository_ctx, bzl_content, lock_content)

    repository_ctx.file("repositories.bzl", "\n".join(bzl_content))
    repository_ctx.file("BUILD.bazel", "")

translate_package_lock = struct(
    doc = _DOC,
    implementation = _translate_package_lock,
    attrs = _ATTRS,
    repository_name = _repo_name,
)
