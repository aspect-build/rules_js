"Convert package-lock.json into starlark Bazel fetches"

_DOC = """Repository rule to generate npm_import rules from package-lock.json file.

The npm lockfile format includes all the information needed to define npm_import rules,
including the integrity hash, as calculated by the package manager.

Instead of manually declaring the `npm_imports`, this helper generates an external repository
containing a helper starlark module `repositories.bzl`, which supplies a loadable macro
`npm_repositories`. This macro creates an `npm_import` for each package.

The generated repository also contains BUILD files declaring targets for the packages
listed as `dependencies` or `devDependencies` in `package.json`, so you can declare
dependencies on those packages without having to repeat version information.

Bazel will only fetch the packages which are required for the requested targets to be analyzed.
Thus it is performant to convert a very large package-lock.json file without concern for
users needing to fetch many unnecessary packages.

Typical usage:
```starlark
load("@aspect_rules_js//js:npm_import.bzl", "translate_package_lock")

# Read the package-lock.json file to automate creation of remaining npm_import rules
translate_package_lock(
    name = "npm_deps",
    package_lock = "//:package-lock.json",
)

load("@npm_deps//:repositories.bzl", "npm_repositories")

npm_repositories()
```

Next, in your BUILD files you can declare dependencies on the packages using the same external repository.

Following the same example, this might look like:

```starlark
nodejs_test(
    name = "test_test",
    data = ["@npm_deps//@types/node"],
    entry_point = "test.js",
)
```
"""

_ATTRS = {
    "package_lock": attr.label(
        doc = """The package-lock.json file.
        
        It should use the lockfileVersion 2, which is produced from npm 7 or higher.""",
        mandatory = True,
    ),
}

_NPM_IMPORT_TMPL = """    # @generated from [package-lock.json snippet here]
    npm_import(
        name = "{name}",
        integrity = "{integrity}",
        package = "{package}",
        version = "{version}",
        deps = {deps},
    )
"""

def _escape(package_name):
    "Make a package name into a valid label without slash or at-sign"
    return package_name.replace("/", "_").replace("@", "_")

def _repo_name(package_name, version):
    "Make an external repository name from a package name and a version"
    return "npm_%s-%s" % (_escape(package_name), version)

def _import_dependencies(lockfile, bzl_out = None):
    # To allow recursion, accept an optional accumulator
    # If it's not present, we need to start with the header of the file
    bzl_out = bzl_out or ["""# @generated by package_lock.bzl from {package_lock}

load("@aspect_rules_js//js:npm_import.bzl", "npm_import")

def npm_repositories():
    "Define external repositories to fetch each tarball individually from npm on-demand."
"""]
    for (name, dep) in lockfile["dependencies"].items():
        if "resolved" not in dep.keys():
            continue
        deps = []
        if "requires" in dep.keys():
            for (n, d) in dep["requires"].items():
                deps.append("@" + _repo_name(n, d))
        bzl_out.extend([_NPM_IMPORT_TMPL.format(
            name = _repo_name(name, dep["version"]),
            package = name,
            version = dep["version"],
            url = dep["resolved"],
            integrity = dep["integrity"],
            deps = deps,
        )])
    return bzl_out

def _define_aliases(repository_ctx, lockfile):
    # The lockfile format refers to the context as the package with empty name.
    # This gives us a way to know which deps the user declared in their package.json
    # (the direct dependencies).
    direct = lockfile["packages"][""]
    direct_names = []
    direct_names.extend(direct.get("devDependencies", {}).keys())
    direct_names.extend(direct.get("dependencies", {}).keys())

    for (direct_name, direct_dep) in lockfile["dependencies"].items():
        if not direct_name in direct_names:
            continue
        dep_build_content = """# @generated by package_lock.bzl

alias(name = "{package}", actual = "{actual}", visibility = ["//visibility:public"])
""".format(
            package = direct_name.split("/")[-1],
            actual = "@" + _repo_name(direct_name, direct_dep["version"]),
        )
        repository_ctx.file(direct_name + "/BUILD.bazel", dep_build_content)

def _translate_package_lock(repository_ctx):
    lock_content = json.decode(repository_ctx.read(repository_ctx.attr.package_lock))
    lock_version = lock_content["lockfileVersion"]
    if lock_version < 2:
        fail("translate_package_lock only works with npm 7 lockfiles (lockfileVersion >= 2), found %s" % lock_version)

    repository_ctx.file("repositories.bzl", "\n".join(_import_dependencies(lock_content)))
    repository_ctx.file("BUILD.bazel", "")
    _define_aliases(repository_ctx, lock_content)

translate_package_lock = struct(
    doc = _DOC,
    implementation = _translate_package_lock,
    attrs = _ATTRS,
    repository_name = _repo_name,
    testonly_import_dependencies = _import_dependencies,
    testonly_define_aliases = _define_aliases,
)
