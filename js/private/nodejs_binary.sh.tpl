#!{bash}
{rlocation_function}

set -o pipefail -o errexit -o nounset

{env}

# --- begin RUNFILES initialization ---
# It helps to determine if we are running on a Windows environment (excludes WSL as it acts like Unix)
function is_windows {
    case "$(uname -s)" in
        CYGWIN*)    local IS_WINDOWS=1 ;;
        MINGW*)     local IS_WINDOWS=1 ;;
        MSYS_NT*)   local IS_WINDOWS=1 ;;
        *)          local IS_WINDOWS=0 ;;
    esac

    echo $IS_WINDOWS
    return
}

# It helps to normalizes paths when running on Windows.
#
# Example:
# C:/Users/XUser/_bazel_XUser/7q7kkv32/execroot/A/b/C -> /c/users/xuser/_bazel_xuser/7q7kkv32/execroot/a/b/c
function normalize_windows_path {
    # Apply the followings paths transformations to normalize paths on Windows
    # -process driver letter
    # -convert path separator
    # -lowercase everything
    echo $(sed -e 's#^\(.\):#/\L\1#' -e 's#\\#/#g' -e 's/[A-Z]/\L&/g' <<< "$1")
    return
}

# Find our runfiles as ${PWD}/${RUNFILES_DIR} is not always correct.
# We need this to launch node with the correct entry point.
#
# Call this program X. X was generated by a genrule and may be invoked
# in many ways:
#   1a) directly by a user, with $0 in the output tree
#   1b) via 'bazel run' (similar to case 1a)
#   2) directly by a user, with $0 in X's runfiles
#   3) by another program Y which has a data dependency on X, with $0 in Y's
#      runfiles
#   4a) via 'bazel test'
#   4b) case 3 in the context of a test
#   5a) by a genrule cmd, with $0 in the output tree
#   6a) case 3 in the context of a genrule
#
# For case 1, $0 will be a regular file, and the runfiles will be
# at $0.runfiles.
# For case 2 or 3, $0 will be a symlink to the file seen in case 1.
# For case 4, $TEST_SRCDIR should already be set to the runfiles by
# blaze.
# Case 5a is handled like case 1.
# Case 6a is handled like case 3.
if [[ -n "${RUNFILES_MANIFEST_ONLY:-}" ]]; then
    # Windows only has a manifest file instead of symlinks.
    if [[ $(is_windows) -eq "1" ]]; then
        # If Windows normalizing the path and case insensitive removing the `/MANIFEST` part of the path
        NORMALIZED_RUNFILES_MANIFEST_FILE_PATH=$(normalize_windows_path $RUNFILES_MANIFEST_FILE)
        RUNFILES=$(sed 's|\/MANIFEST$||i' <<< $NORMALIZED_RUNFILES_MANIFEST_FILE_PATH)
    else
        RUNFILES=${RUNFILES_MANIFEST_FILE%/MANIFEST}
    fi
elif [[ -n "${TEST_SRCDIR:-}" ]]; then
    # Case 4, bazel has identified runfiles for us.
    RUNFILES="${TEST_SRCDIR:-}"
else
    case "$0" in
    /*) self="$0" ;;
    *) self="$PWD/$0" ;;
    esac
    while true; do
        if [[ -e "$self.runfiles" ]]; then
            RUNFILES="$self.runfiles"
            break
        fi

        if [[ $self == *.runfiles/* ]]; then
            RUNFILES="${self%%.runfiles/*}.runfiles"
            # don't break; this is a last resort for case 6b
        fi

        if [[ ! -L "$self" ]]; then
            break;
        fi

        readlink="$(readlink "$self")"
        if [[ "$readlink" = /* ]]; then
            self="$readlink"
        else
            # resolve relative symlink
            self="${self%%/*}/$readlink"
        fi
    done

    if [[ -z "$RUNFILES" ]]; then
        echo " >>>> FAIL: RUNFILES environment variable is not set. <<<<" >&2
        exit 1
    fi
fi
export RUNFILES
# --- end RUNFILES initialization ---

if [[ "$PWD" == *"/bazel-out/"* ]]; then
    # We in runfiles, find the execroot.
    # Look for `bazel-out` which is used to determine the the path to `execroot/my_wksp`. This works in
    # all cases including on rbe where the execroot is a path such as `/b/f/w`. For example, when in
    # runfiles on rbe, bazel runs the process in a directory such as
    # `/b/f/w/bazel-out/k8-fastbuild/bin/path/to/pkg/some_test.sh.runfiles/my_wksp`. From here we can
    # determine the execroot `b/f/w` by finding the first instance of bazel-out.
    readonly bazel_out="/bazel-out/"
    readonly rest=${PWD#*$bazel_out}
    readonly index=$(( ${#PWD} - ${#rest} - ${#bazel_out} ))
    if [[ ${index} < 0 ]]; then
        echo "No 'bazel-out' folder found in path '${PWD}'!" >&2
        exit 1
    fi
    EXECROOT=${PWD:0:${index}}
    node="$PWD/{node}"
    entry_point="$PWD/{entry_point}"
else
    # We are in execroot or in some other context all together such as a nodejs_image or a manually
    # run nodejs_binary.
    EXECROOT=$PWD
    node="$RUNFILES/{workspace_name}/{node}"
    entry_point="$RUNFILES/{workspace_name}/{entry_point}"
    if [ -z "${BAZEL_BINDIR:-}" ]; then
        printf "\n>>>> FAIL: BAZEL_BINDIR must be set when not running out of runfiles so nodejs_binary can run out of the output tree on build actions. <<<<\n\n" >&2
        exit 1
    fi
    cd $BAZEL_BINDIR
fi

if [ ! -f "$node" ]; then
    printf "\n>>>> FAIL: The node binary '$node' not found in runfiles. <<<<\n\n" >&2
    exit 1
fi
if [ ! -x "$node" ]; then
    printf "\n>>>> FAIL: The node binary '$node' is not executable. <<<<\n\n" >&2
    exit 1
fi
if [ ! -f "$entry_point" ]; then
    printf "\n>>>> FAIL: The entry_point '$entry_point' not found in runfiles. <<<<\n\n" >&2
    exit 1
fi

if [[ "${BAZEL_CHDIR:-}" ]]; then
    cd $BAZEL_CHDIR
fi

echo $PWD

"$node" "$entry_point" "$@"
