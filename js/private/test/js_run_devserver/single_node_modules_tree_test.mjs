import { createServer } from 'http-server'
import path from 'path'
import puppeteer from 'puppeteer'
import webpack from 'webpack'
import HtmlWebpackPlugin from 'html-webpack-plugin'

// Test shouldn't take anywhere near 60 seconds to run. If it does, something
// hung and we should just exit
setTimeout(() => {
    console.error('Test took >60 seconds, exiting')
    process.exit(1)
}, 60000)

try {
    await main()
} catch (error) {
    console.error(error)
    process.exit(1)
}

// No graceful cleanup of the server needed at the end (closing it tends to hang 
// anyway), so just exit
process.exit(0)

// -----------------------------------------------------------------------------

/**
 * Performs a test to make sure only a single node_modules tree is made
 * available in the js_run_devserver sandbox, as reported in
 * https://github.com/aspect-build/rules_js/issues/1204
 * 
 * This test is done as the following:
 * 
 * 1. Uses Webpack to compile a very basic React app that simply displays a 
 *    single <button> on the page. 
 * 2. Uses http-server to serve the generated index.html file.
 * 3. Uses puppeteer to launch Chrome and check for the <button> on the page.
 * 
 * If the button doesn't exist on the page, it's because multiple copies of 
 * React have entered the bundle and are causing an error to be thrown.
 */
async function main() {
    // 1. Compile the webpack app - outputs to './dist'
    await compileApp()

    // 2. Start http server
    const port = 19000
    await startServer('./dist', port)

    // 3. Launch Chrome and look for the button
    console.log('Starting test...')
    const browser = await puppeteer.launch({ headless: 'new' })
    const page = await browser.newPage()
    await page.goto(`http://localhost:${port}`)
    try {
        await page.waitForSelector('button', { timeout: 10000 })
    } catch (error) {
        console.error(
            `Could not find the <button> element that would be displayed on the ` +
            `page if there was no React error from multiple copies being present`
        )
        throw error;
    } finally {
        await browser.close()
    }
    console.log('Test complete - button component successfully found')
}

async function compileApp() {
    return new Promise((resolve, reject) => {
        const config = {
            mode: 'development',
            entry: './app',
            output: {
                path: path.join(process.cwd(), 'dist'),
            },
            resolve: {
                extensions: ['.jsx', '.js'],
                symlinks: true,
            },
            plugins: [new HtmlWebpackPlugin()],
        }

        webpack(config, (err, stats) => {
            if (err) {
                console.error(err.stack || err)
                if (err.details) {
                    console.error(err.details)
                }
                reject(err)
            } else {
                if (stats.hasErrors()) {
                    console.error(stats.toJson().errors)
                    reject('An error occurred during compilation - see above')
                } else {
                    resolve()
                }
            }
        })
    })
}

/**
 * Starts an http-server instance
 * 
 * @param root The root directory to serve
 * @param port The port to serve on
 */
async function startServer(root, port) {
    const server = createServer({
        root,
        cache: -1,
    })

    return new Promise((resolve) => {
        server.listen(port, () => resolve(server))
    })
}
