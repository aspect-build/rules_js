load("@aspect_bazel_lib//lib:copy_to_bin.bzl", "copy_to_bin")
load("@npm//:defs.bzl", "npm_link_all_packages")
load("@npm//js/private/test/node-patches:@babel/cli/package_json.bzl", babel_bin = "bin")
load("//js:defs.bzl", "js_library", "js_test")

TESTS = [
    "escape.js",
]

MJS_TESTS = [
    "lstat.mjs",
    "opendir.mjs",
    "readdir.mjs",
    "readlink.mjs",
    "realpath.mjs",
]

CJS_TESTS = [
    t.replace(".mjs", ".cjs")
    for t in MJS_TESTS
]

# Multiple node toolchains for testing across versions
TOOLCHAINS_NAMES = [
    "node16",
    "node18",
    "node20",
    "node22",
    "node24",
]

TOOLCHAINS_VERSIONS = [
    select({
        "@bazel_tools//src/conditions:linux_x86_64": "@%s_linux_amd64//:node_toolchain" % n,
        "@bazel_tools//src/conditions:darwin": "@%s_darwin_amd64//:node_toolchain" % n,
        "@bazel_tools//src/conditions:windows": "@%s_windows_amd64//:node_toolchain" % n,
    })
    for n in TOOLCHAINS_NAMES
]

npm_link_all_packages()

# We need to copy the entry points to the bin so that the tests below don't follow the execroot
# symlink back to the source tree since the fs patches are not on for the tests as they are the code
# under test
[
    copy_to_bin(
        name = "copy_entry_{}".format(t),
        srcs = [t],
    )
    for t in TESTS + MJS_TESTS
]

js_library(
    name = "babel_config",
    srcs = ["babel.config.js"],
    deps = [
        ":node_modules/@babel/plugin-transform-modules-commonjs",
    ],
)

babel_bin.babel(
    name = "babel_mjs2js",
    srcs = MJS_TESTS + [":babel_config"],
    outs = [t.replace(".mjs", ".cjs") for t in MJS_TESTS],
    args = [
        "--extensions",
        ".mjs",
        "--out-file-extension",
        ".cjs",
        "--out-dir",
        ".",
    ] + MJS_TESTS,
    chdir = package_name(),  # to automatically pickup babel.config.js
)

# Basic tests
[
    [
        [
            # The primary tests, both .js and .mjs
            [
                js_test(
                    name = "{}_{}{}_test".format(
                        t.replace(".mjs", "").replace(".js", ""),
                        toolchain_name,
                        "_esmloader" if useEsmLoader else "",
                    ),
                    data = [
                        ":node_modules/inline-fixtures",
                        "//js/private/node-patches/src:compile",
                    ],
                    entry_point = "copy_entry_{}".format(t),
                    env = {
                        "NODE_PATCHES_TEST_ESM_LOADER": "1" if useEsmLoader else "",
                    },
                    node_options = ["--expose-internals"] if useEsmLoader else [],
                    node_toolchain = toolchain,
                    patch_node_esm_loader = False,
                    patch_node_fs = False,
                    # Without node patches on for these tests, the program is going to escape the sandbox if it
                    # is on since the fs patches are not on for the tests as they are the code under test
                    tags = ["no-sandbox"],
                )
                for t in TESTS + MJS_TESTS
            ],

            # The .cjs tests converted from .mjs
            [
                js_test(
                    name = "{}_{}{}_cjs_test".format(
                        t.replace(".cjs", ""),
                        toolchain_name,
                        "_esmloader" if useEsmLoader else "",
                    ),
                    data = [
                        ":node_modules/inline-fixtures",
                        "//js/private/node-patches/src:compile",
                    ],
                    entry_point = "copy_entry_{}".format(t) if (t in TESTS) else t,
                    env = {
                        "NODE_PATCHES_TEST_ESM_LOADER": "1" if useEsmLoader else "",
                    },
                    node_options = ["--expose-internals"] if useEsmLoader else [],
                    node_toolchain = toolchain,
                    patch_node_esm_loader = False,
                    patch_node_fs = False,
                    # Without node patches on for these tests, the program is going to escape the sandbox if it
                    # is on since the fs patches are not on for the tests as they are the code under test
                    tags = ["no-sandbox"],
                )
                for t in CJS_TESTS
            ],
        ]
        for toolchain_name, toolchain in zip(
            TOOLCHAINS_NAMES,
            TOOLCHAINS_VERSIONS,
        )
    ]
    for useEsmLoader in [
        False,
        True,
    ]
]

# Node process spawning tests
[
    js_test(
        name = "spawn_test_%s" % toolchain_name,
        args = [
            "$(rootpath //js/private/test/node-patches:spawn_node_path.js)",
            "$(rootpath //js/private/test/node-patches:spawn_node_path.sh)",
            "$(rootpath //js/private/test/node-patches:spawn_patch_depth.js)",
            "$(rootpath //js/private/test/node-patches:spawn_patch_depth.sh)",
        ],
        data = [
            "//js/private/test/node-patches:spawn_node_path.js",
            "//js/private/test/node-patches:spawn_node_path.sh",
            "//js/private/test/node-patches:spawn_patch_depth.js",
            "//js/private/test/node-patches:spawn_patch_depth.sh",
        ],
        entry_point = "spawn.js",
        node_toolchain = toolchain,
        patch_node_fs = True,
    )
    for toolchain_name, toolchain in zip(
        TOOLCHAINS_NAMES,
        TOOLCHAINS_VERSIONS,
    )
]

# TODO: this doesn't fail with patch_node_esm_loader=False, need failing test!!
[
    js_test(
        name = "esm_test_%s" % toolchain_name,
        data = [":lib"],
        entry_point = "esm.mjs",
        node_toolchain = toolchain,
        patch_node_esm_loader = True,
        patch_node_fs = True,
        preserve_symlinks_main = False,  # TODO: test both?
    )
    for toolchain_name, toolchain in zip(
        TOOLCHAINS_NAMES,
        TOOLCHAINS_VERSIONS,
    )
    if toolchain_name != "node16"  # ESM json loading not supported on Node 16
]

# A basic library with esm imports, esm json data etc
js_library(
    name = "lib",
    srcs = [
        "data.json",
        "lib.mjs",
    ],
)
