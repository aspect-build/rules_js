"""Starlark generation helpers for npm_translate_lock.
"""

load("@bazel_skylib//lib:paths.bzl", "paths")
load(":npm_translate_lock_helpers.bzl", "helpers")
load(":starlark_codegen_utils.bzl", "starlark_codegen_utils")
load(":utils.bzl", "utils")

################################################################################

_DEFS_BZL_FILENAME = "defs.bzl"

_BIN_TMPL = \
    """load("{repo_package_json_bzl}", _bin = "bin")
bin = _bin
"""

_FP_STORE_TMPL = \
    """        _npm_local_package_store(
            package_store_name = "{package_store_name}",
            src = "{npm_package_target}",
            package = "{package}",
            version = "{version}",
            deps = {deps},
            visibility = ["//visibility:public"],
            tags = ["manual"],
        )"""

_FP_DIRECT_TMPL = \
    """
# Generated npm_link_package_store for linking of first-party "{pkg}" package
# buildifier: disable=function-docstring
def _fp_link_{i}(alias = None):
    _npm_local_link_package_store(
        name = "node_modules/{pkg}" if alias == None else "node_modules/{{}}".format(alias),
        package = alias,
        src = "//{root_package}:{package_store_root}/node_modules/{package_store_name}",{maybe_visibility}
    )"""

_BZL_LIBRARY_TMPL = \
    """bzl_library(
    name = "{name}_bzl_library",
    srcs = ["{src}"],
    deps = ["{dep}"],
    visibility = ["//visibility:public"],
)
"""

_PACKAGE_JSON_BZL_FILENAME = "package_json.bzl"
_RESOLVED_JSON_FILENAME = "resolved.json"

# buildifier: disable=function-docstring
def generate_repository_files(rctx_name, attr, state, npm_imports):
    # empty line after bzl docstring since buildifier expects this if this file is vendored in
    generated_by_prefix = "\"\"\"@generated by npm_translate_lock(name = \"{}\", pnpm_lock = \"{}\")\"\"\"\n".format(helpers.to_apparent_repo_name(rctx_name), str(attr.pnpm_lock))

    importers = state.importers()
    packages = state.packages()
    root_package = state.root_package()

    final_rctx_files = {}

    rctx_files = {
        "BUILD.bazel": [
            """load("@aspect_rules_js//js:defs.bzl", "js_binary")""",
            """load("@bazel_skylib//:bzl_library.bzl", "bzl_library")""",
            """load("@bazel_skylib//rules:write_file.bzl", "write_file")""",
            """
# A no-op run target that can be run to invalidate the repository
# to update the pnpm lockfile. Useful under bzlmod where
# `bazel sync --only=repo` is a no-op.
write_file(name="noop", out="noop.js", content=["#!/usr/bin/env node"])
js_binary(name = "sync", entry_point = "noop.js")
""",
            "",
            "exports_files({})".format(starlark_codegen_utils.to_list_attr([
                _DEFS_BZL_FILENAME,
            ])),
        ],
    }

    # Map repo-relative package paths to lockfile importer paths
    package_to_importer = {}
    for import_path in importers.keys():
        link_package = helpers.link_package(root_package, import_path)
        package_to_importer[link_package] = import_path

    # Collect first-party file: links in packages
    fp_links = {}
    for package_key, package_info in packages.items():
        name = package_info["name"]
        version = package_info["version"]
        deps = package_info["dependencies"]
        resolution = package_info["resolution"]
        if resolution.get("type", None) == "directory":
            dep_path = helpers.link_package(root_package, resolution["directory"])
            transitive_deps = {}
            for dep_name, dep_key in deps.items():
                package_store_name = utils.package_store_name(dep_key)
                dep_store_target = '"//{root_package}:{package_store_root}/node_modules/{package_store_name}"'.format(
                    root_package = root_package,
                    package_store_name = package_store_name,
                    package_store_root = utils.package_store_root,
                )
                if dep_store_target not in transitive_deps:
                    transitive_deps[dep_store_target] = [dep_name]
                else:
                    transitive_deps[dep_store_target].append(dep_name)

            # collapse alias lists to comma separated strings for each store target
            for dep_store_target in transitive_deps.keys():
                transitive_deps[dep_store_target] = ",".join(transitive_deps[dep_store_target])
            fp_links[package_key] = {
                "key": package_key,
                "package": name,
                "version": version,
                "path": dep_path,
                "link_packages": {},
                "deps": transitive_deps,
            }

    # Collect first-party links in importers
    for link_package, import_path in package_to_importer.items():
        importer = importers[import_path]
        prod_deps = importer["dependencies"] | importer["optional_dependencies"]
        all_deps = prod_deps | importer["dev_dependencies"]
        for dep_name, dep_key in all_deps.items():
            is_dev = dep_name not in prod_deps
            if dep_key.find("@file:") != -1:
                if not dep_key in fp_links.keys():
                    # Ignore file: dependencies on packages such as file: tarballs
                    if dep_key in packages:
                        continue

                    msg = "Expected to file: referenced package {} in first-party links {}".format(dep_key, fp_links.keys())
                    fail(msg)
                if link_package not in fp_links[dep_key]["link_packages"]:
                    fp_links[dep_key]["link_packages"][link_package] = {}
                fp_links[dep_key]["link_packages"][link_package][dep_name] = is_dev
            elif dep_key.startswith("link:"):
                dep_link = utils.link_to_importer(dep_key)
                dep_path = helpers.link_package(root_package, dep_link)
                if not fp_links.get(dep_path, False):
                    transitive_deps = {}
                    raw_deps = {}
                    if importers.get(dep_link, False):
                        raw_deps = importers[dep_link]["dependencies"] | importers[dep_link]["optional_dependencies"]
                    for raw_dep_name, raw_dep_key in raw_deps.items():
                        package_store_name = utils.package_store_name(raw_dep_key)
                        dep_store_target = '"//{root_package}:{package_store_root}/node_modules/{package_store_name}"'.format(
                            root_package = root_package,
                            package_store_name = package_store_name,
                            package_store_root = utils.package_store_root,
                        )
                        if dep_store_target not in transitive_deps:
                            transitive_deps[dep_store_target] = [raw_dep_name]
                        else:
                            transitive_deps[dep_store_target].append(raw_dep_name)

                    for dep_store_target in transitive_deps.keys():
                        transitive_deps[dep_store_target] = ",".join(transitive_deps[dep_store_target])

                    # note this is the (first) name used to reference this package and not
                    # necessarily the proper self-declared package name
                    package = dep_name

                    # rules_js using 0.0.0 to indicate local first-party packages
                    version = "0.0.0"

                    fp_links[dep_path] = {
                        "key": "{}@{}".format(package, version),
                        "package": package,
                        "version": version,
                        "path": dep_path,
                        "link_packages": {},
                        "deps": transitive_deps,
                    }

                if link_package not in fp_links[dep_path]["link_packages"]:
                    fp_links[dep_path]["link_packages"][link_package] = {}
                fp_links[dep_path]["link_packages"][link_package][dep_name] = is_dev

    npm_link_packages_const = """_IMPORTER_PACKAGES = {pkgs}""".format(
        pkgs = str(package_to_importer.keys()),
    )

    # Generate visibility configuration first to check if it's actually non-empty
    npm_visibility_config_generated = _generate_npm_visibility_config(attr.package_visibility)

    # Check if the generated visibility config is actually non-empty
    has_package_visibility = attr.package_visibility != None and npm_visibility_config_generated != None

    # Only keep the generated config if it's non-empty
    npm_visibility_config = npm_visibility_config_generated if has_package_visibility else None

    # Generate package locations mapping only if we have visibility config
    npm_package_locations = _generate_npm_package_locations(fp_links, npm_imports) if has_package_visibility else None

    # Build the validation call conditionally
    validation_call = ""
    if has_package_visibility:
        validation_call = """
    # Validate package visibility before creating any targets
    _npm_validate_package_visibility(bazel_package, _NPM_PACKAGE_LOCATIONS, _NPM_PACKAGE_VISIBILITY)
"""

    npm_link_all_packages_bzl = [
        """\
# buildifier: disable=function-docstring
def npm_link_all_packages(name = "node_modules", imported_links = [], prod = True, dev = True):
    if name != "node_modules":
        fail("npm_link_all_packages: customizing 'name' is not supported")
    if not prod and not dev:
        fail("npm_link_all_packages: at least one of 'prod' or 'dev' must be True")

    bazel_package = native.package_name()
    root_package = "{root_package}"
    is_root = bazel_package == root_package
    is_importer = bazel_package in _IMPORTER_PACKAGES
    if not is_root and not is_importer:
        msg = "The npm_link_all_packages() macro loaded from {defs_bzl_file} and called in bazel package '%s' may only be called in bazel packages that correspond to the pnpm root package or pnpm workspace projects. Projects are discovered from the pnpm-lock.yaml and may be missing if the lockfile is out of date. Root package: '{root_package}', pnpm workspace projects: %s" % (bazel_package, {link_packages_comma_separated})
        fail(msg)
{validation_call}
""".format(
            defs_bzl_file = "@{}//:{}".format(rctx_name, _DEFS_BZL_FILENAME),
            link_packages_comma_separated = "\"'\" + \"', '\".join(_IMPORTER_PACKAGES) + \"'\"" if package_to_importer else "\"\"",
            root_package = root_package,
            pnpm_lock_label = attr.pnpm_lock,
            validation_call = validation_call,
        ),
    ]

    # Imports and header comments at the top of the generated file
    defs_bzl_header = []

    # The store invocations and setup code done once at the root package
    stores_bzl = []

    # The code for the first-party link factory functions
    link_factories_bzl = []

    # The per-package code sections for links and targets that will later be merged into the main lists
    links_pkg_bzl = {}

    # The links and scopes per package
    links_targets = {}
    links_scope_targets = {}

    # Generate the store_bzl and associated links_* code for every npm package
    for (i, _import) in enumerate(npm_imports):
        defs_bzl = "@%s%s//:defs.bzl" % (_import.repo_name, utils.links_repo_suffix)
        if _import.link_packages:
            defs_bzl_header.append(
                """load("{defs_bzl}", link_{i} = "npm_link_imported_package_store_internal", store_{i} = "npm_imported_package_store_internal")""".format(
                    defs_bzl = defs_bzl,
                    i = i,
                ),
            )
        else:
            defs_bzl_header.append(
                """load("{defs_bzl}", store_{i} = "npm_imported_package_store_internal")""".format(
                    defs_bzl = defs_bzl,
                    i = i,
                ),
            )

        stores_bzl.append("""        store_{i}()""".format(i = i))
        for link_package, _link_aliases in _import.link_packages.items():
            link_aliases = _link_aliases or [_import.package]

            link_importer_key = package_to_importer.get(link_package)
            link_importer = importers.get(link_importer_key)

            # the build file for the package being linked
            build_file = "{}/{}".format(link_package, "BUILD.bazel") if link_package else "BUILD.bazel"
            if build_file not in rctx_files:
                rctx_files[build_file] = []

            if link_package not in links_pkg_bzl:
                links_pkg_bzl[link_package] = []
            if link_package not in links_scope_targets:
                links_scope_targets[link_package] = {}
            if link_package not in links_targets:
                links_targets[link_package] = {"prod": [], "dev": []}

            # for each alias of this package
            for link_alias in link_aliases:
                is_alias = link_alias != _import.package
                is_dev = link_alias not in link_importer["dependencies"] and link_alias not in link_importer["optional_dependencies"]

                links_pkg_bzl[link_package].append("""            link_{i}({maybe_alias}{maybe_dev})""".format(
                    i = i,
                    maybe_alias = '"{}"'.format(link_alias) if is_alias else "",
                    maybe_dev = (", " if is_alias else "") + "dev=True" if is_dev else "",
                ))

                if "//visibility:public" in _import.package_visibility:
                    link_target = '":node_modules/{alias}"'.format(alias = link_alias)

                    links_targets[link_package]["dev" if is_dev else "prod"].append(link_target)

                    if link_alias[0] == "@":
                        package_scope = link_alias[:link_alias.find("/", 1)]
                        if package_scope not in links_scope_targets[link_package]:
                            links_scope_targets[link_package][package_scope] = []
                        links_scope_targets[link_package][package_scope].append(link_target)

                # the resolved.json for this alias of the package
                resolved_json_rel_path = "{}/{}".format(link_alias, _RESOLVED_JSON_FILENAME)
                resolved_json_file_path = "{}/{}".format(link_package, resolved_json_rel_path) if link_package else resolved_json_rel_path

                final_rctx_files[resolved_json_file_path] = json.encode({
                    # Allow consumers to auto-detect this filetype
                    "$schema": "https://docs.aspect.build/rules/aspect_rules_js/docs/npm_translate_lock",
                    "version": _import.version,
                    "integrity": _import.integrity,
                })
                rctx_files[build_file].append("exports_files([\"{}\"])".format(resolved_json_rel_path))

            # the package_json.bzl for this package
            if _import.package_info["has_bin"]:
                if attr.generate_bzl_library_targets:
                    rctx_files[build_file].append("""load("@bazel_skylib//:bzl_library.bzl", "bzl_library")""")

                    for link_alias in link_aliases:
                        rctx_files[build_file].append(_BZL_LIBRARY_TMPL.format(
                            name = link_alias,
                            src = ":{}/{}".format(link_alias, _PACKAGE_JSON_BZL_FILENAME),
                            dep = "@{repo_name}//:{package_name}_bzl_library".format(
                                repo_name = helpers.to_apparent_repo_name(_import.repo_name),
                                package_name = link_alias.split("/")[-1],
                            ),
                        ))

                # re-export the package_json.bzl for each linkage of this package
                for link_alias in link_aliases:
                    package_json_bzl_file_path = "{}/{}/{}".format(link_package, link_alias, _PACKAGE_JSON_BZL_FILENAME) if link_package else "{}/{}".format(link_alias, _PACKAGE_JSON_BZL_FILENAME)
                    repo_package_json_bzl = "@{repo_name}//:{package_json_bzl}".format(
                        repo_name = _import.repo_name,
                        package_json_bzl = _PACKAGE_JSON_BZL_FILENAME,
                    )
                    rctx_files[package_json_bzl_file_path] = [_BIN_TMPL.format(
                        repo_package_json_bzl = repo_package_json_bzl,
                    )]

    # Generate the first-party package stores and linking of first-party packages
    for i, fp_link in enumerate(fp_links.values()):
        fp_key = fp_link["key"]
        fp_package = fp_link["package"]
        fp_version = fp_link["version"]
        fp_path = fp_link["path"]
        fp_deps = fp_link["deps"]
        fp_target = "//{}:{}".format(
            fp_path,
            attr.npm_package_target_name.replace("{dirname}", paths.basename(fp_path)),
        )
        fp_package_store_name = utils.package_store_name(fp_key)

        # Add first-party package links to npm_link_targets for each package that uses it
        for fp_link_package, aliases in fp_link["link_packages"].items():
            if fp_link_package not in links_targets:
                links_targets[fp_link_package] = {"prod": [], "dev": []}

            for alias, is_dev in aliases.items():
                link_target = '":node_modules/{alias}"'.format(alias = alias)

                links_targets[fp_link_package]["dev" if is_dev else "prod"].append(link_target)

                if alias[0] == "@":
                    package_scope = alias[:alias.find("/", 1)]
                    if fp_link_package not in links_scope_targets:
                        links_scope_targets[fp_link_package] = {}
                    if package_scope not in links_scope_targets[fp_link_package]:
                        links_scope_targets[fp_link_package][package_scope] = []
                    links_scope_targets[fp_link_package][package_scope].append(link_target)

        stores_bzl.append(_FP_STORE_TMPL.format(
            deps = starlark_codegen_utils.to_dict_attr(fp_deps, 3, quote_key = False),
            npm_package_target = fp_target,
            package = fp_package,
            version = fp_version,
            package_store_name = fp_package_store_name,
            package_store_root = utils.package_store_root,
        ))

        # Generate a single _FP_DIRECT_TMPL block with all link packages
        if fp_link["link_packages"]:
            package_visibility, _ = helpers.gather_values_from_matching_names(True, attr.package_visibility, "*", fp_package)
            if not package_visibility:
                package_visibility = None

            link_factories_bzl.append(_FP_DIRECT_TMPL.format(
                i = i,
                maybe_visibility = "\n        link_visibility = {},".format(package_visibility) if package_visibility else "",
                pkg = fp_package,
                root_package = root_package,
                package_store_name = fp_package_store_name,
                package_store_root = utils.package_store_root,
            ))

        for link_package, aliases in fp_link["link_packages"].items():
            if link_package not in links_pkg_bzl:
                links_pkg_bzl[link_package] = []
            for alias in aliases.keys():
                if alias == fp_package:
                    links_pkg_bzl[link_package].append("""            _fp_link_{i}()""".format(i = i))
                else:
                    links_pkg_bzl[link_package].append("""            _fp_link_{i}("{alias}")""".format(i = i, alias = alias))

    if stores_bzl:
        npm_link_all_packages_bzl.append("""    if is_root:""")
        npm_link_all_packages_bzl.extend(stores_bzl)

    # Start with empty link and scope targets
    npm_link_all_packages_bzl.append("""
    link_targets = None
    scope_targets = None
""")

    # Invoke and collect link targets based on package
    if links_pkg_bzl:
        npm_link_all_packages_bzl.append("""    if is_importer:""")
        first_link = True
        for link_package, bzl in links_pkg_bzl.items():
            npm_link_all_packages_bzl.append("""        {els}if bazel_package == "{pkg}":""".format(
                els = "" if first_link else "el",
                pkg = link_package,
            ))
            npm_link_all_packages_bzl.extend(bzl)

            if link_package in links_targets and (links_targets[link_package]["prod"] or links_targets[link_package]["dev"]):
                npm_link_all_packages_bzl.append("""            link_targets = {targets}""".format(
                    targets = starlark_codegen_utils.to_list_attr(links_targets[link_package]["prod"] + links_targets[link_package]["dev"], 3, 4, quote_value = False),
                ))

            if links_scope_targets.get(link_package):
                npm_link_all_packages_bzl.append("""            scope_targets = {targets}""".format(
                    targets = starlark_codegen_utils.to_dict_list_attr(links_scope_targets[link_package], 3, 4, quote_list_value = False),
                ))

            first_link = False

    # Invoke and collect link targets from the `imported_links` param
    npm_link_all_packages_bzl.append("""    
    for link_fn in imported_links:
        new_link_targets, new_scope_targets = link_fn(name, prod, dev)
        if not link_targets:
            link_targets = []
        link_targets.extend(new_link_targets)
        for _scope, _targets in new_scope_targets.items():
            if not scope_targets:
                scope_targets = {}
            if _scope not in scope_targets:
                scope_targets[_scope] = []
            scope_targets[_scope].extend(_targets)
""")

    # Generate catch all & scoped js_library targets
    npm_link_all_packages_bzl.append("""
    if scope_targets:
        for scope, scoped_targets in scope_targets.items():
            _js_library(
                name = "node_modules/{}".format(scope),
                srcs = scoped_targets,
                tags = ["manual"],
                visibility = ["//visibility:public"],
            )

    if is_importer:
        _js_library(
            name = "node_modules",
            srcs = link_targets if link_targets else [],
            tags = ["manual"],
            visibility = ["//visibility:public"],
        )""")

    npm_link_targets_bzl = _generate_npm_link_targets(links_targets)

    defs_bzl_header.append("")
    defs_bzl_header.append("# buildifier: disable=bzl-visibility")
    defs_bzl_header.append("""load("@aspect_rules_js//js:defs.bzl", _js_library = "js_library")""")

    # Only add visibility load if package visibility is configured
    if has_package_visibility:
        defs_bzl_header.append("")
        defs_bzl_header.append("# buildifier: disable=bzl-visibility")
        defs_bzl_header.append("""load("@aspect_rules_js//npm/private:npm_package_visibility.bzl", _npm_validate_package_visibility = "validate_npm_package_visibility")""")

    if fp_links:
        defs_bzl_header.append("")
        defs_bzl_header.append("# buildifier: disable=bzl-visibility")
        defs_bzl_header.append("""load("@aspect_rules_js//npm/private:npm_link_package_store.bzl", _npm_local_link_package_store = "npm_local_link_package_store_internal")""")
        defs_bzl_header.append("")
        defs_bzl_header.append("# buildifier: disable=bzl-visibility")
        defs_bzl_header.append("""load("@aspect_rules_js//npm/private:npm_package_store.bzl", _npm_package_store = "npm_package_store", _npm_local_package_store = "npm_local_package_store_internal")""")

    # Build the defs.bzl file contents
    defs_bzl_contents = [
        "\n".join(defs_bzl_header),
        "",
        npm_link_packages_const,
    ]

    # Only include visibility config and locations if package visibility is configured
    defs_bzl_contents.extend(["", npm_visibility_config] if npm_visibility_config else [])
    defs_bzl_contents.extend(["", npm_package_locations] if npm_package_locations else [])

    defs_bzl_contents.extend([
        "",
        "\n".join(npm_link_all_packages_bzl),
        "",
        "\n".join(npm_link_targets_bzl),
        "",
        "\n".join(link_factories_bzl),
    ])

    rctx_files[_DEFS_BZL_FILENAME] = defs_bzl_contents

    for filename, contents in attr.additional_file_contents.items():
        if not rctx_files.get(filename, False):
            rctx_files[filename] = contents
        elif filename.endswith(".bzl"):
            # bzl files are special cased since all load statements must go at the top
            load_statements = []
            other_statements = []
            for content in contents:
                if content.startswith("load("):
                    load_statements.append(content)
                else:
                    other_statements.append(content)
            rctx_files[filename] = load_statements + rctx_files[filename] + other_statements
        else:
            rctx_files[filename].extend(contents)

    return final_rctx_files | {
        filename: generated_by_prefix + "\n" + "\n".join(contents).rstrip() + "\n"
        for filename, contents in rctx_files.items()
    }

def _generate_npm_link_targets(links_targets):
    """Generate the npm_link_targets() macro given the links_targets struct"""
    npm_link_targets_bzl = [
        """\
# buildifier: disable=function-docstring
def npm_link_targets(name = "node_modules", package = None, prod = True, dev = True):
    if name != "node_modules":
        fail("npm_link_targets: customizing 'name' is not supported")
    if not prod and not dev:
        fail("npm_link_targets: at least one of 'prod' or 'dev' must be True")

    bazel_package = package if package != None else native.package_name()

    link_targets = []
""",
    ]
    first_link = True
    for link_package, lists in links_targets.items():
        npm_link_targets_bzl.append("""    {els}if bazel_package == "{pkg}":""".format(
            els = "" if first_link else "el",
            pkg = link_package,
        ))
        if lists["prod"]:
            npm_link_targets_bzl.append("""        if prod:""")
            npm_link_targets_bzl.append("""            link_targets.extend({targets})""".format(
                targets = starlark_codegen_utils.to_list_attr(lists["prod"], 3, 4, quote_value = False),
            ))

        if lists["dev"]:
            npm_link_targets_bzl.append("""        if dev:""")
            npm_link_targets_bzl.append("""            link_targets.extend({targets})""".format(
                targets = starlark_codegen_utils.to_list_attr(lists["dev"], 3, 4, quote_value = False),
            ))
        first_link = False
    npm_link_targets_bzl.append("""    return link_targets""")
    return npm_link_targets_bzl

def _generate_npm_visibility_config(package_visibility_attr):
    """Generate visibility configuration for npm packages"""
    if not package_visibility_attr:
        return None

    # Convert the attribute to a proper dictionary with list values
    config_dict = {}
    for package_pattern, visibility_list in package_visibility_attr.items():
        config_dict[package_pattern] = list(visibility_list)

    return "_NPM_PACKAGE_VISIBILITY = {}".format(
        starlark_codegen_utils.to_dict_attr(config_dict, 0, quote_value = False),
    )

def _generate_npm_package_locations(fp_links, npm_imports):
    """Generate a dictionary mapping locations to the package names available at each location."""
    location_to_packages = {}

    # Add first-party packages
    for fp_link in fp_links.values():
        fp_package = fp_link["package"]
        fp_link_packages = list(fp_link["link_packages"].keys())
        for location in fp_link_packages:
            if location not in location_to_packages:
                location_to_packages[location] = []
            if fp_package not in location_to_packages[location]:
                location_to_packages[location].append(fp_package)

    # Add npm imports
    for _import in npm_imports:
        if _import.link_packages:
            for link_package, link_aliases in _import.link_packages.items():
                aliases_to_add = link_aliases or [_import.package]
                for alias in aliases_to_add:
                    if link_package not in location_to_packages:
                        location_to_packages[link_package] = []
                    if alias not in location_to_packages[link_package]:
                        location_to_packages[link_package].append(alias)

    # TODO(zbarsky): `sorted_map` could just return the dict's items which is what `to_dict_attr` wants anyway.
    location_to_packages = utils.sorted_map(location_to_packages)

    return "_NPM_PACKAGE_LOCATIONS = {}".format(
        starlark_codegen_utils.to_dict_attr(location_to_packages, 0, quote_value = False),
    )
