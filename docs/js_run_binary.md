<!-- Generated with Stardoc: http://skydoc.bazel.build -->

Runs a js_binary as a build action.

This macro wraps Aspect bazel-lib's run_binary (https://github.com/aspect-build/bazel-lib/blob/main/lib/run_binary.bzl)
and adds attributes and features specific to rules_js's js_binary.

Load this with,

```starlark
load("@aspect_rules_js//js:defs.bzl", "js_run_binary")
```


<a id="#js_run_binary"></a>

## js_run_binary

<pre>
js_run_binary(<a href="#js_run_binary-name">name</a>, <a href="#js_run_binary-tool">tool</a>, <a href="#js_run_binary-env">env</a>, <a href="#js_run_binary-srcs">srcs</a>, <a href="#js_run_binary-outs">outs</a>, <a href="#js_run_binary-out_dirs">out_dirs</a>, <a href="#js_run_binary-args">args</a>, <a href="#js_run_binary-chdir">chdir</a>, <a href="#js_run_binary-stdout">stdout</a>, <a href="#js_run_binary-stderr">stderr</a>, <a href="#js_run_binary-exit_code_out">exit_code_out</a>,
              <a href="#js_run_binary-silent_on_success">silent_on_success</a>, <a href="#js_run_binary-copy_srcs_to_bin">copy_srcs_to_bin</a>, <a href="#js_run_binary-include_transitive_sources">include_transitive_sources</a>, <a href="#js_run_binary-include_declarations">include_declarations</a>,
              <a href="#js_run_binary-include_npm_linked_packages">include_npm_linked_packages</a>, <a href="#js_run_binary-log_level">log_level</a>, <a href="#js_run_binary-mnemonic">mnemonic</a>, <a href="#js_run_binary-progress_message">progress_message</a>,
              <a href="#js_run_binary-execution_requirements">execution_requirements</a>, <a href="#js_run_binary-stamp">stamp</a>, <a href="#js_run_binary-patch_node_fs">patch_node_fs</a>, <a href="#js_run_binary-kwargs">kwargs</a>)
</pre>

Wrapper around @aspect_bazel_lib 'run_binary' that adds convienence attributes for using a 'js_binary' tool.

This rule does not require Bash `native.genrule`.


**PARAMETERS**


| Name  | Description | Default Value |
| :------------- | :------------- | :------------- |
| <a id="js_run_binary-name"></a>name |  Target name   |  none |
| <a id="js_run_binary-tool"></a>tool |  The tool to run in the action.<br><br>Should be a js_binary rule. Use Aspect bazel-lib's run_binary (https://github.com/aspect-build/bazel-lib/blob/main/lib/run_binary.bzl) for other *_binary rule types.   |  none |
| <a id="js_run_binary-env"></a>env |  Environment variables of the action.<br><br>Subject to <code>$(location)</code> and make variable expansion.   |  <code>{}</code> |
| <a id="js_run_binary-srcs"></a>srcs |  Additional inputs of the action.<br><br>These labels are available for <code>$(location)</code> expansion in <code>args</code> and <code>env</code>.   |  <code>[]</code> |
| <a id="js_run_binary-outs"></a>outs |  Output files generated by the action.<br><br>These labels are available for <code>$(location)</code> expansion in <code>args</code> and <code>env</code>.   |  <code>[]</code> |
| <a id="js_run_binary-out_dirs"></a>out_dirs |  Output directories generated by the action.<br><br>These labels are _not_ available for <code>$(location)</code> expansion in <code>args</code> and <code>env</code> since they are not pre-declared labels created via attr.output_list(). Output directories are declared instead by <code>ctx.actions.declare_directory</code>.   |  <code>[]</code> |
| <a id="js_run_binary-args"></a>args |  Command line arguments of the binary.<br><br>Subject to <code>$(location)</code> and make variable expansion.   |  <code>[]</code> |
| <a id="js_run_binary-chdir"></a>chdir |  Working directory to run the binary or test in, relative to the workspace.<br><br>This overrides the chdir value if set on the js_binary tool target.<br><br>By default, Bazel always runs in the workspace root.<br><br>To run in the directory containing the js_run_binary under the source tree, use <code>chdir = package_name()</code> (or if you're in a macro, use <code>native.package_name()</code>).<br><br>To run in the output directory where the js_run_binary writes outputs, use <code>chdir = "$(RULEDIR)"</code><br><br>WARNING: this will affect other paths passed to the program, either as arguments or in configuration files, which are workspace-relative.<br><br>You may need <code>../../</code> segments to re-relativize such paths to the new working directory.   |  <code>None</code> |
| <a id="js_run_binary-stdout"></a>stdout |  set to capture the stdout of the binary to a file, which can later be used as an input to another target subject to the same semantics as <code>outs</code>   |  <code>None</code> |
| <a id="js_run_binary-stderr"></a>stderr |  set to capture the stderr of the binary to a file, which can later be used as an input to another target subject to the same semantics as <code>outs</code>   |  <code>None</code> |
| <a id="js_run_binary-exit_code_out"></a>exit_code_out |  set to capture the exit code of the binary to a file, which can later be used as an input to another target subject to the same semantics as <code>outs</code>. Note that setting this will force the binary to exit 0.<br><br>If the binary creates outputs and these are declared, they must still be created   |  <code>None</code> |
| <a id="js_run_binary-silent_on_success"></a>silent_on_success |  produce no output on stdout nor stderr when program exits with status code 0.<br><br>This makes node binaries match the expected bazel paradigm.   |  <code>True</code> |
| <a id="js_run_binary-copy_srcs_to_bin"></a>copy_srcs_to_bin |  When True, all srcs files are copied to the output tree that are not already there.   |  <code>True</code> |
| <a id="js_run_binary-include_transitive_sources"></a>include_transitive_sources |  see 'js_filegroup' documentation   |  <code>True</code> |
| <a id="js_run_binary-include_declarations"></a>include_declarations |  see 'js_filegroup' documentation   |  <code>False</code> |
| <a id="js_run_binary-include_npm_linked_packages"></a>include_npm_linked_packages |  see 'js_filegroup' documentation   |  <code>True</code> |
| <a id="js_run_binary-log_level"></a>log_level |  Set the logging level of the 'js_binary' tool.<br><br>This overrides the log level set on the 'js_binary' tool target.   |  <code>None</code> |
| <a id="js_run_binary-mnemonic"></a>mnemonic |  A one-word description of the action, for example, CppCompile or GoLink.   |  <code>"JsRunBinary"</code> |
| <a id="js_run_binary-progress_message"></a>progress_message |  Progress message to show to the user during the build, for example, "Compiling foo.cc to create foo.o". The message may contain %{label}, %{input}, or %{output} patterns, which are substituted with label string, first input, or output's path, respectively. Prefer to use patterns instead of static strings, because the former are more efficient.   |  <code>None</code> |
| <a id="js_run_binary-execution_requirements"></a>execution_requirements |  Information for scheduling the action.<br><br>For example,<br><br><pre><code> execution_requirements = {     "no-cache": "1", }, </code></pre><br><br>See https://docs.bazel.build/versions/main/be/common-definitions.html#common.tags for useful keys.   |  <code>None</code> |
| <a id="js_run_binary-stamp"></a>stamp |  Whether to include build status files as inputs to the tool. Possible values:<br><br>- <code>stamp = 0 (default)</code>: Never include build status files as inputs to the tool.     This gives good build result caching.     Most tools don't use the status files, so including them in <code>--stamp</code> builds makes those     builds have many needless cache misses.     (Note: this default is different from most rules with an integer-typed <code>stamp</code> attribute.) - <code>stamp = 1</code>: Always include build status files as inputs to the tool, even in     [--nostamp](https://docs.bazel.build/versions/main/user-manual.html#flag--stamp) builds.     This setting should be avoided, since it is non-deterministic.     It potentially causes remote cache misses for the target and     any downstream actions that depend on the result. - <code>stamp = -1</code>: Inclusion of build status files as inputs is controlled by the     [--[no]stamp](https://docs.bazel.build/versions/main/user-manual.html#flag--stamp) flag.     Stamped targets are not rebuilt unless their dependencies change.<br><br>Default value is <code>0</code> since the majority of js_run_binary targets in a build graph typically do not use build status files and including them for all js_run_binary actions whenever <code>--stamp</code> is set would result in invalidating the entire graph and would prevent cache hits. Stamping is typically done in terminal targets when building release artifacts and stamp should typically be set explicitly in these targets to <code>-1</code> so it is enabled when the <code>--stamp</code> flag is set.<br><br>When stamping is enabled, an additional two environment variables will be set for the action:     - <code>BAZEL_STABLE_STATUS_FILE</code>     - <code>BAZEL_VOLATILE_STATUS_FILE</code><br><br>These files can be read and parsed by the action, for example to pass some values to a bundler.   |  <code>0</code> |
| <a id="js_run_binary-patch_node_fs"></a>patch_node_fs |  Patch the to Node.js <code>fs</code> API (https://nodejs.org/api/fs.html) for this node program to prevent the program from following symlinks out of the execroot, runfiles and the sandbox.<br><br>When enabled, <code>js_binary</code> patches the Node.js sync and async <code>fs</code> API functions <code>lstat</code>, <code>readlink</code>, <code>realpath</code>, <code>readdir</code> and <code>opendir</code> so that the node program being run cannot resolve symlinks out of the execroot and the runfiles tree. When in the sandbox, these patches prevent the program being run from resolving symlinks out of the sandbox.<br><br>When disabled, node programs can leave the execroot, runfiles and sandbox by following symlinks which can lead to non-hermetic behavior.   |  <code>True</code> |
| <a id="js_run_binary-kwargs"></a>kwargs |  Additional arguments   |  none |


