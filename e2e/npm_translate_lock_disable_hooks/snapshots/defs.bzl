"""@generated by npm_translate_lock(name = "npm", pnpm_lock = "@@//:pnpm-lock.yaml")"""

load("@@aspect_rules_js~~npm~npm__at_aspect-test_c__2.0.0__links//:defs.bzl", link_0 = "npm_link_imported_package_store", store_0 = "npm_imported_package_store")

# buildifier: disable=bzl-visibility
load("@aspect_rules_js//js:defs.bzl", _js_library = "js_library")

_LINK_PACKAGES = [""]

_NPM_PACKAGE_VISIBILITY = {}

# buildifier: disable=function-docstring
def npm_link_all_packages(name = "node_modules", imported_links = [], prod = True, dev = True):
    if not prod and not dev:
        fail("npm_link_all_packages: at least one of 'prod' or 'dev' must be True")

    bazel_package = native.package_name()
    root_package = ""
    is_root = bazel_package == root_package
    link = bazel_package in _LINK_PACKAGES
    if not is_root and not link:
        msg = "The npm_link_all_packages() macro loaded from @aspect_rules_js~~npm~npm//:defs.bzl and called in bazel package '%s' may only be called in bazel packages that correspond to the pnpm root package or pnpm workspace projects. Projects are discovered from the pnpm-lock.yaml and may be missing if the lockfile is out of date. Root package: '', pnpm workspace projects: %s" % (bazel_package, "'" + "', '".join(_LINK_PACKAGES) + "'")
        fail(msg)

    # Validate package visibility before creating any targets
    _validate_npm_package_visibility(bazel_package)

    link_targets = []
    scope_targets = {}

    for link_fn in imported_links:
        new_link_targets, new_scope_targets = link_fn(name, prod, dev)
        link_targets.extend(new_link_targets)
        for _scope, _targets in new_scope_targets.items():
            if _scope not in scope_targets:
                scope_targets[_scope] = []
            scope_targets[_scope].extend(_targets)

    if is_root:
        store_0(name)
    if link:
        if bazel_package == "":
            link_0("{}/@aspect-test/c".format(name), link_root_name = name, link_alias = "@aspect-test/c")
            link_targets.append(":{}/@aspect-test/c".format(name))
            if "@aspect-test" not in scope_targets:
                scope_targets["@aspect-test"] = [link_targets[-1]]
            else:
                scope_targets["@aspect-test"].append(link_targets[-1])

    for scope, scoped_targets in scope_targets.items():
        _js_library(
            name = "{}/{}".format(name, scope),
            srcs = scoped_targets,
            tags = ["manual"],
            visibility = ["//visibility:public"],
        )

    _js_library(
        name = name,
        srcs = link_targets,
        tags = ["manual"],
        visibility = ["//visibility:public"],
    )

def _validate_npm_package_visibility(accessing_package):
    """Validate that accessing_package can access npm packages that would be created here"""

    # Get packages that would be created in this location
    packages_to_validate = []

    if accessing_package == "":
        packages_to_validate.append("@aspect-test/c")


    # Validate each package
    for package_name in packages_to_validate:
        if not _check_package_visibility(accessing_package, package_name):
            fail("""
Package visibility violation:

  Package: {}
  Requested by: {}

This package is not visible from your location.
Check the package_visibility configuration in your npm_translate_lock rule.

For more information, see: https://docs.aspect.build/rules/aspect_rules_js/docs/npm_translate_lock#package_visibility
""".format(package_name, accessing_package))

def _check_package_visibility(accessing_package, package_name):
    """Check if accessing_package can access package_name"""

    # Get visibility rules for this package
    visibility_rules = _get_package_visibility_rules(package_name)

    # Check each visibility rule
    for rule in visibility_rules:
        if rule == "//visibility:public":
            return True

        # Package-specific access: //packages/foo:__pkg__
        if rule == "//" + accessing_package + ":__pkg__":
            return True

        # Subpackage access: //packages/foo:__subpackages__
        if rule.endswith(":__subpackages__"):
            rule_package = rule[2:-16]  # Remove "//" and ":__subpackages__"
            if accessing_package.startswith(rule_package + "/") or accessing_package == rule_package:
                return True

        # Target-specific access: //packages/foo:target
        if rule.startswith("//" + accessing_package + ":"):
            return True

    return False

def _get_package_visibility_rules(package_name):
    """Get visibility rules for package_name from configuration"""

    # Direct package match
    if package_name in _NPM_PACKAGE_VISIBILITY:
        return _NPM_PACKAGE_VISIBILITY[package_name]

    # Wildcard match
    if "*" in _NPM_PACKAGE_VISIBILITY:
        return _NPM_PACKAGE_VISIBILITY["*"]

    # Default to public if not specified
    return ["//visibility:public"]


# buildifier: disable=function-docstring
def npm_link_targets(name = "node_modules", package = None, prod = True, dev = True):
    if not prod and not dev:
        fail("npm_link_targets: at least one of 'prod' or 'dev' must be True")

    bazel_package = package if package != None else native.package_name()
    link = bazel_package in _LINK_PACKAGES

    link_targets = []

    if link:
        if bazel_package == "":
            if prod:
                link_targets.append(":{}/@aspect-test/c".format(name))
            if dev:
                pass
    return link_targets
